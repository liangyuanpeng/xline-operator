/*
Kubernetes

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1.27.3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// AuthorizationV1ApiService AuthorizationV1Api service
type AuthorizationV1ApiService service

type ApiCreateAuthorizationV1NamespacedLocalSubjectAccessReviewRequest struct {
	ctx context.Context
	ApiService *AuthorizationV1ApiService
	namespace string
	body *IoK8sApiAuthorizationV1LocalSubjectAccessReview
	dryRun *string
	fieldManager *string
	fieldValidation *string
	pretty *string
}

func (r ApiCreateAuthorizationV1NamespacedLocalSubjectAccessReviewRequest) Body(body IoK8sApiAuthorizationV1LocalSubjectAccessReview) ApiCreateAuthorizationV1NamespacedLocalSubjectAccessReviewRequest {
	r.body = &body
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateAuthorizationV1NamespacedLocalSubjectAccessReviewRequest) DryRun(dryRun string) ApiCreateAuthorizationV1NamespacedLocalSubjectAccessReviewRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateAuthorizationV1NamespacedLocalSubjectAccessReviewRequest) FieldManager(fieldManager string) ApiCreateAuthorizationV1NamespacedLocalSubjectAccessReviewRequest {
	r.fieldManager = &fieldManager
	return r
}

// fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
func (r ApiCreateAuthorizationV1NamespacedLocalSubjectAccessReviewRequest) FieldValidation(fieldValidation string) ApiCreateAuthorizationV1NamespacedLocalSubjectAccessReviewRequest {
	r.fieldValidation = &fieldValidation
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateAuthorizationV1NamespacedLocalSubjectAccessReviewRequest) Pretty(pretty string) ApiCreateAuthorizationV1NamespacedLocalSubjectAccessReviewRequest {
	r.pretty = &pretty
	return r
}

func (r ApiCreateAuthorizationV1NamespacedLocalSubjectAccessReviewRequest) Execute() (*IoK8sApiAuthorizationV1LocalSubjectAccessReview, *http.Response, error) {
	return r.ApiService.CreateAuthorizationV1NamespacedLocalSubjectAccessReviewExecute(r)
}

/*
CreateAuthorizationV1NamespacedLocalSubjectAccessReview Method for CreateAuthorizationV1NamespacedLocalSubjectAccessReview

create a LocalSubjectAccessReview

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateAuthorizationV1NamespacedLocalSubjectAccessReviewRequest
*/
func (a *AuthorizationV1ApiService) CreateAuthorizationV1NamespacedLocalSubjectAccessReview(ctx context.Context, namespace string) ApiCreateAuthorizationV1NamespacedLocalSubjectAccessReviewRequest {
	return ApiCreateAuthorizationV1NamespacedLocalSubjectAccessReviewRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return IoK8sApiAuthorizationV1LocalSubjectAccessReview
func (a *AuthorizationV1ApiService) CreateAuthorizationV1NamespacedLocalSubjectAccessReviewExecute(r ApiCreateAuthorizationV1NamespacedLocalSubjectAccessReviewRequest) (*IoK8sApiAuthorizationV1LocalSubjectAccessReview, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IoK8sApiAuthorizationV1LocalSubjectAccessReview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationV1ApiService.CreateAuthorizationV1NamespacedLocalSubjectAccessReview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.k8s.io/v1/namespaces/{namespace}/localsubjectaccessreviews"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterValueToString(r.namespace, "namespace")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.dryRun != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dryRun", r.dryRun, "")
	}
	if r.fieldManager != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldManager", r.fieldManager, "")
	}
	if r.fieldValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldValidation", r.fieldValidation, "")
	}
	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAuthorizationV1SelfSubjectAccessReviewRequest struct {
	ctx context.Context
	ApiService *AuthorizationV1ApiService
	body *IoK8sApiAuthorizationV1SelfSubjectAccessReview
	dryRun *string
	fieldManager *string
	fieldValidation *string
	pretty *string
}

func (r ApiCreateAuthorizationV1SelfSubjectAccessReviewRequest) Body(body IoK8sApiAuthorizationV1SelfSubjectAccessReview) ApiCreateAuthorizationV1SelfSubjectAccessReviewRequest {
	r.body = &body
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateAuthorizationV1SelfSubjectAccessReviewRequest) DryRun(dryRun string) ApiCreateAuthorizationV1SelfSubjectAccessReviewRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateAuthorizationV1SelfSubjectAccessReviewRequest) FieldManager(fieldManager string) ApiCreateAuthorizationV1SelfSubjectAccessReviewRequest {
	r.fieldManager = &fieldManager
	return r
}

// fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
func (r ApiCreateAuthorizationV1SelfSubjectAccessReviewRequest) FieldValidation(fieldValidation string) ApiCreateAuthorizationV1SelfSubjectAccessReviewRequest {
	r.fieldValidation = &fieldValidation
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateAuthorizationV1SelfSubjectAccessReviewRequest) Pretty(pretty string) ApiCreateAuthorizationV1SelfSubjectAccessReviewRequest {
	r.pretty = &pretty
	return r
}

func (r ApiCreateAuthorizationV1SelfSubjectAccessReviewRequest) Execute() (*IoK8sApiAuthorizationV1SelfSubjectAccessReview, *http.Response, error) {
	return r.ApiService.CreateAuthorizationV1SelfSubjectAccessReviewExecute(r)
}

/*
CreateAuthorizationV1SelfSubjectAccessReview Method for CreateAuthorizationV1SelfSubjectAccessReview

create a SelfSubjectAccessReview

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAuthorizationV1SelfSubjectAccessReviewRequest
*/
func (a *AuthorizationV1ApiService) CreateAuthorizationV1SelfSubjectAccessReview(ctx context.Context) ApiCreateAuthorizationV1SelfSubjectAccessReviewRequest {
	return ApiCreateAuthorizationV1SelfSubjectAccessReviewRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IoK8sApiAuthorizationV1SelfSubjectAccessReview
func (a *AuthorizationV1ApiService) CreateAuthorizationV1SelfSubjectAccessReviewExecute(r ApiCreateAuthorizationV1SelfSubjectAccessReviewRequest) (*IoK8sApiAuthorizationV1SelfSubjectAccessReview, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IoK8sApiAuthorizationV1SelfSubjectAccessReview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationV1ApiService.CreateAuthorizationV1SelfSubjectAccessReview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.k8s.io/v1/selfsubjectaccessreviews"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.dryRun != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dryRun", r.dryRun, "")
	}
	if r.fieldManager != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldManager", r.fieldManager, "")
	}
	if r.fieldValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldValidation", r.fieldValidation, "")
	}
	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAuthorizationV1SelfSubjectRulesReviewRequest struct {
	ctx context.Context
	ApiService *AuthorizationV1ApiService
	body *IoK8sApiAuthorizationV1SelfSubjectRulesReview
	dryRun *string
	fieldManager *string
	fieldValidation *string
	pretty *string
}

func (r ApiCreateAuthorizationV1SelfSubjectRulesReviewRequest) Body(body IoK8sApiAuthorizationV1SelfSubjectRulesReview) ApiCreateAuthorizationV1SelfSubjectRulesReviewRequest {
	r.body = &body
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateAuthorizationV1SelfSubjectRulesReviewRequest) DryRun(dryRun string) ApiCreateAuthorizationV1SelfSubjectRulesReviewRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateAuthorizationV1SelfSubjectRulesReviewRequest) FieldManager(fieldManager string) ApiCreateAuthorizationV1SelfSubjectRulesReviewRequest {
	r.fieldManager = &fieldManager
	return r
}

// fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
func (r ApiCreateAuthorizationV1SelfSubjectRulesReviewRequest) FieldValidation(fieldValidation string) ApiCreateAuthorizationV1SelfSubjectRulesReviewRequest {
	r.fieldValidation = &fieldValidation
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateAuthorizationV1SelfSubjectRulesReviewRequest) Pretty(pretty string) ApiCreateAuthorizationV1SelfSubjectRulesReviewRequest {
	r.pretty = &pretty
	return r
}

func (r ApiCreateAuthorizationV1SelfSubjectRulesReviewRequest) Execute() (*IoK8sApiAuthorizationV1SelfSubjectRulesReview, *http.Response, error) {
	return r.ApiService.CreateAuthorizationV1SelfSubjectRulesReviewExecute(r)
}

/*
CreateAuthorizationV1SelfSubjectRulesReview Method for CreateAuthorizationV1SelfSubjectRulesReview

create a SelfSubjectRulesReview

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAuthorizationV1SelfSubjectRulesReviewRequest
*/
func (a *AuthorizationV1ApiService) CreateAuthorizationV1SelfSubjectRulesReview(ctx context.Context) ApiCreateAuthorizationV1SelfSubjectRulesReviewRequest {
	return ApiCreateAuthorizationV1SelfSubjectRulesReviewRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IoK8sApiAuthorizationV1SelfSubjectRulesReview
func (a *AuthorizationV1ApiService) CreateAuthorizationV1SelfSubjectRulesReviewExecute(r ApiCreateAuthorizationV1SelfSubjectRulesReviewRequest) (*IoK8sApiAuthorizationV1SelfSubjectRulesReview, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IoK8sApiAuthorizationV1SelfSubjectRulesReview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationV1ApiService.CreateAuthorizationV1SelfSubjectRulesReview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.k8s.io/v1/selfsubjectrulesreviews"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.dryRun != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dryRun", r.dryRun, "")
	}
	if r.fieldManager != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldManager", r.fieldManager, "")
	}
	if r.fieldValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldValidation", r.fieldValidation, "")
	}
	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAuthorizationV1SubjectAccessReviewRequest struct {
	ctx context.Context
	ApiService *AuthorizationV1ApiService
	body *IoK8sApiAuthorizationV1SubjectAccessReview
	dryRun *string
	fieldManager *string
	fieldValidation *string
	pretty *string
}

func (r ApiCreateAuthorizationV1SubjectAccessReviewRequest) Body(body IoK8sApiAuthorizationV1SubjectAccessReview) ApiCreateAuthorizationV1SubjectAccessReviewRequest {
	r.body = &body
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateAuthorizationV1SubjectAccessReviewRequest) DryRun(dryRun string) ApiCreateAuthorizationV1SubjectAccessReviewRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateAuthorizationV1SubjectAccessReviewRequest) FieldManager(fieldManager string) ApiCreateAuthorizationV1SubjectAccessReviewRequest {
	r.fieldManager = &fieldManager
	return r
}

// fieldValidation instructs the server on how to handle objects in the request (POST/PUT/PATCH) containing unknown or duplicate fields. Valid values are: - Ignore: This will ignore any unknown fields that are silently dropped from the object, and will ignore all but the last duplicate field that the decoder encounters. This is the default behavior prior to v1.23. - Warn: This will send a warning via the standard warning response header for each unknown field that is dropped from the object, and for each duplicate field that is encountered. The request will still succeed if there are no other errors, and will only persist the last of any duplicate fields. This is the default in v1.23+ - Strict: This will fail the request with a BadRequest error if any unknown fields would be dropped from the object, or if any duplicate fields are present. The error returned from the server will contain all unknown and duplicate fields encountered.
func (r ApiCreateAuthorizationV1SubjectAccessReviewRequest) FieldValidation(fieldValidation string) ApiCreateAuthorizationV1SubjectAccessReviewRequest {
	r.fieldValidation = &fieldValidation
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateAuthorizationV1SubjectAccessReviewRequest) Pretty(pretty string) ApiCreateAuthorizationV1SubjectAccessReviewRequest {
	r.pretty = &pretty
	return r
}

func (r ApiCreateAuthorizationV1SubjectAccessReviewRequest) Execute() (*IoK8sApiAuthorizationV1SubjectAccessReview, *http.Response, error) {
	return r.ApiService.CreateAuthorizationV1SubjectAccessReviewExecute(r)
}

/*
CreateAuthorizationV1SubjectAccessReview Method for CreateAuthorizationV1SubjectAccessReview

create a SubjectAccessReview

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAuthorizationV1SubjectAccessReviewRequest
*/
func (a *AuthorizationV1ApiService) CreateAuthorizationV1SubjectAccessReview(ctx context.Context) ApiCreateAuthorizationV1SubjectAccessReviewRequest {
	return ApiCreateAuthorizationV1SubjectAccessReviewRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IoK8sApiAuthorizationV1SubjectAccessReview
func (a *AuthorizationV1ApiService) CreateAuthorizationV1SubjectAccessReviewExecute(r ApiCreateAuthorizationV1SubjectAccessReviewRequest) (*IoK8sApiAuthorizationV1SubjectAccessReview, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IoK8sApiAuthorizationV1SubjectAccessReview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationV1ApiService.CreateAuthorizationV1SubjectAccessReview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.k8s.io/v1/subjectaccessreviews"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.dryRun != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dryRun", r.dryRun, "")
	}
	if r.fieldManager != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldManager", r.fieldManager, "")
	}
	if r.fieldValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fieldValidation", r.fieldValidation, "")
	}
	if r.pretty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pretty", r.pretty, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAuthorizationV1APIResourcesRequest struct {
	ctx context.Context
	ApiService *AuthorizationV1ApiService
}

func (r ApiGetAuthorizationV1APIResourcesRequest) Execute() (*IoK8sApimachineryPkgApisMetaV1APIResourceList, *http.Response, error) {
	return r.ApiService.GetAuthorizationV1APIResourcesExecute(r)
}

/*
GetAuthorizationV1APIResources Method for GetAuthorizationV1APIResources

get available resources

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAuthorizationV1APIResourcesRequest
*/
func (a *AuthorizationV1ApiService) GetAuthorizationV1APIResources(ctx context.Context) ApiGetAuthorizationV1APIResourcesRequest {
	return ApiGetAuthorizationV1APIResourcesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IoK8sApimachineryPkgApisMetaV1APIResourceList
func (a *AuthorizationV1ApiService) GetAuthorizationV1APIResourcesExecute(r ApiGetAuthorizationV1APIResourcesRequest) (*IoK8sApimachineryPkgApisMetaV1APIResourceList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IoK8sApimachineryPkgApisMetaV1APIResourceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationV1ApiService.GetAuthorizationV1APIResources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.k8s.io/v1/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["BearerToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
